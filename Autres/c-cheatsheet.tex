\documentclass[10pt,a4paper,french]{article}
\usepackage{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{../latex/clovisai}

\makeindex
\makeglossaries

\begin{document}

\title{Cheatsheet C/C++}
\author{Ivan Canet}
\maketitle

\begin{abstract} % ARTICLE ONLY
Feuille d'aide pour la syntaxe de C/C++.
\end{abstract}

\tableofcontents

\section{Introduction}

\subsection{Fichiers et compilation}

En C et en C++, la compilation est séparée en deux étapes.
\begin{enumerate}
\item Traduction en code machine,
\item Édition des liens.
\end{enumerate}

Cela est fait pour que la compilation soit plus rapide : on ne recompile que ce qui n'est pas déjà compilé.

Pour cela, les fichiers sources ({\tt .c}) sont transformés en fichiers de liens ({\tt .o}). Chaque fichier source est compilé indépendamment : le problème est que les fichiers dépendent souvent les uns des autres (avec {\tt include}). Pour régler le problème, on crée des fichiers headers ({\tt .h}) qui contiennent les signatures des fonctions. Comme ça, la compilation est plus indépendante.

Pour éviter qu'un fichier header soit utilisé en plusieurs fois, on leur assigne une variable de préprocesseur:

\begin{minted}{c}
#ifndef NOM_DU_FICHIER.h
#define NOM_DU_FICHIER.h

// Les signatures de fonctions

#endif
\end{minted}

\subsection{Makefile}

\begin{minted}{makefile}
CFLAGS = --std=c11 -Wall -Wextra -pedantic
EXEC = main // Remplacer par le fichier contenant le main

$(EXEC): *.o

%.o: %.c

clean:
	rm *.o

distclean: clean
	rm $(EXEC)
\end{minted}

\part{Syntaxe}

\section{Allocation statique}

\subsection{Variables}

\begin{minted}{c}
int a;        // Déclaration seule
int a = 2;    // Déclaration et initialisation
a = 3;        // Modification
\end{minted}

\subsection{Pointeurs}

\begin{minted}{c}
int a;
int *pa;      // Déclaration d'un pointeur d'entiers
pa = &a;      // Récupération de l'adresse de 'a' dans 'pa'
int b = *pa;  // Récupération de la valeur pointée par 'pa', donc 'a'
\end{minted}

\subsection{Tableaux et chaînes de caractères}

\begin{minted}{c}
int a[] = {0, 1, 2, 3};  // Déclaration et initialisation de tableau d'entiers
int b[10];               // Déclaration d'un tableau vide
\end{minted}

En réalité, un tableau est un pointeur caché, donc:

\begin{minted}{c}
int a[] = {0};           // Un tableau d'une case
int *b  = {0};           // Exactement la même chose
int indice = 0;
int c = a[indice];       // Récupération d'une case à un indice
int d = *(b+indice);     // Exactement la même chose
\end{minted}

Les chaînes de caractères sont des tableaux de {\tt char} qui se finissent par le caractère de code ASCII 0.

\begin{minted}{c}
char *a = {'H', 'e', 'l', 'l', 'o', 0}; // Déclaration d'une chaîne de caractères
char *b = "Hello";                       // Même chose
\end{minted}

Puisque les tableaux sont des pointeurs cachés, on peut faire:

\begin{minted}{c}
char *a = "Hello";
int *b = *a;
while(*b++ != 0)
    // Quelque chose avec *b
\end{minted}

\subsection{Structures}

Déclaration de structure:

\begin{minted}{c}
struct Temps {
    int heure;
    int minute;
    int seconde;
};
\end{minted}

Création d'une variable de type {\tt Temps}:

\begin{minted}{c}
struct Temps t = {
    .heure = 1,
    .minute = 2,
    .seconde = 3
};
\end{minted}

Accès à un élément de la structure:

\begin{minted}{c}
printf("L'heure est: %s", &t.heure); // On passe une adresse
struct *Temps pt = &t;
printf("L'heure est: %s", t->heure); // Syntaxe simplifiée pour (*t).heure
\end{minted}

\subsection{Typedef}

On peut utiliser typedef pour créer un type customisé (un alias):

\begin{minted}{c}
typedef int Matrice[3][3];
Matrice rotation = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}};
\end{minted}

\section{Allocation dynamique}

\subsection{Allocation}

On veut allouer dynamiquement des structures (comme exemple, cela marche pour tout):

\begin{minted}{c}
struct Temps {
    int heure;
    int minute;
    int seconde;
};
\end{minted}

Première étape: créer un pointeur qui va servir de tableau de temps:

\begin{minted}{c}
struct *Temps heures;
int taille = 32;
\end{minted}

Deuxième étape: on utilise {\tt malloc} (dans {\tt memory.h}) pour réserver la place dans la mémoire:

\begin{minted}{c}
heures = malloc(taille * sizeof(struct Temps));
if(heures == NULL) // malloc a raté, il y a un problème
    doSomething();
\end{minted}

\subsection{Libération}

Quand on a fini d'utiliser le tableau, il ne faut pas oublier de le libérer:

\begin{minted}{c}
free(heures);  // Suppression du contenu
heures = NULL; // Suppression du pointeur (on utilise 'nullptr' en C++)
\end{minted}

\paragraph{Différences en C++}

En C++ on appelle {\tt delete} au lieu de {\tt free}.

\subsection{Réallocation dynamique}

On peut utiliser {\tt realloc} pour changer la taille réservée.

\begin{minted}{c}
heures = realloc(heures, 30 * sizeof(struct Temps));
\end{minted}

Si la taille est disponible au même endroit, la nouvelle taille est réservée. Si la taille n'est pas disponible au même endroit, l'espace précédemment réservé est copié et un nouveau pointeur est renvoyé au nouvel endroit. Si jamais aucun endroit n'est trouvé, {\tt realloc} renvoie un pointeur vide.

\section{Paramètres}

\subsection{Passage par copie}

Par défaut les variables sont copiées d'une fonction à une autre:

\begin{minted}{c}
void println(int a){
    printf(a + '\n');
}

int a = 2;
println(a);
\end{minted}

\subsection{Passage par pointeur}

On copie le pointeur, pas la variable. Pour des tableaux ou des structures, c'est beaucoup mieux.

\begin{minted}{c}
void println(int *a){
    printf(*a + '\n');
}

int a = 2;
println(&a);
\end{minted}

\subsection{Passage par référence (C++)}

Exactement comme le passage par pointeur, mais en plus lisible.

\begin{minted}{c}
void println(int &a){
    printf(a + '\n');
}

int a = 2;
println(a);
\end{minted}

\part{Systèmes d'Exploitation}

\section{Définition}

Le Système d'Exploitation a pour but de gérer les périphériques, le partage du temps de calcul\ldots

Le principe de l'API est de permettre d'écrire et de lire dans des descripteurs (par exemple des fichiers, mais aussi la souris\ldots)

On fait la différence entre:
\begin{description}
\item[Type block] Par exemple les fichiers ; on lit souvent avec un tampon pour lire des données,
\item[Type caractère] On lit très peu de données, par exemple depuis le clavier ou la souris.
\end{description}

Un processeur ne peut effectuer qu'une seule opération (un seul processus) à un instant donné. Par contre, les entrées/sorties (E/S) peuvent être exécutées en parallèle des processus (mais une seule opération E/S à la fois).

\section{Appels système}

\subsection{Gestion des processus}

\subsubsection{Identification des processus (PID)}

\paragraph{Récupérer le PID du processus actuel}
\begin{minted}{c}
int pid = getpid();
\end{minted}

\paragraph{Récupérer le PID du parent}
\begin{minted}{c}
pid_t pid = getparentpid();
\end{minted}

\subsubsection{Faire une copie du processus}

\paragraph{Copier un processus (Fork)}
Quand on appelle la fonction fork, elle copie le processus complet (même variables, même endroit dans le code\ldots) ; pour le processus enfant elle renvoie 0, et pour le processus parent elle renvoie le PID de l'enfant.
\begin{minted}{c}
// On copie le processus actuel
pid_t pid = fork();
// On regarde si on est le parent ou l'enfant
if(pid == 0){
    printf("Je suis l'enfant (%d)", getpid());
}else{
    printf("Je suis le parent (%d), mon enfant est %d", getpid(), pid);
}
\end{minted}

De manière plus simple, on peut écrire:
\begin{minted}{c}
if(fork() == 0){
    //...
    exit(0);
}
\end{minted}

\subsubsection{Attendre la fin d'un processus \& récupérer son code d'arrêt}

\paragraph{Attendre la fin d'un processus}
\begin{minted}{c}
// Attendre la fin du processus
waitpid(pid, NULL, 0);
\end{minted}

\paragraph{Récupérer le code d'erreur d'un processus}
On souhaite récupérer le code d'arrêt du fils.

\begin{minted}{c}
pid_t pid = fork();
if(pid == 0){
    // Quelque chose
    exit(2); // Code d'erreur 2
}
int erreur;
waitpid(pid, &erreur, 0);
printf("Le code d'erreur était: %d", erreur);
\end{minted}

\subsubsection{Exécuter une commande externe}

\paragraph{execl}
Permet d'exécuter un programme externe dans le processus actuel. Le processus sera terminé quand le programme terminera.
\begin{minted}{c}
execl(CHEMIN, COMMANDE, OPTIONS..., NULL);
execl("/bin/ls", "ls", "-l", NULL);
\end{minted}

\paragraph{execv}
Comme {\tt execl} ; la différence est que les options sont données dans un tableau au lieu d'être directement les paramètres de la commande.
\begin{minted}{c}
char *arg[] = {"ls", "-l", NULL};
execv("/bin/ls", arg);
\end{minted}

\paragraph{execlp et execvp}
On utilise `p' pour `path' : elles sont identiques à leur contrepartie dans le `p', mais acceptent un chemin relatif:
\begin{minted}{c}
execlp("ls", "ls", "-l", NULL);
char *arg[] = {"ls", "-l", NULL};
execvp("ls", arg);
\end{minted}

\subsection{Gestion des signaux}

\section{Fichiers}

\subsection{Ouverture et fermeture}

Les descripteurs de fichiers correspondent au type {\tt FILE*}, on peut l'ouvrir grâce à {\tt fopen} :

\begin{minted}{c}
FILE * f = fopen("donnees.txt", "rw");
\end{minted}

Le mode d'écriture peut être:
\begin{description}
\item[Read (r)] Lecture seule, le fichier doit exister.
\item[Write (w)] Écriture seule, le fichier est créé s'il n'existe pas, et vidé s'il existe.
\item[Append (a)] Écriture seule, le fichier est créé s'il n'existe pas, on écrit à la fin.
\item[Read-write (rw)] Lecture et écriture.
\end{description}

Il faut penser à fermer le fichier avec:

\begin{minted}{c}
fclose(f);
\end{minted}

\subsection{Lecture et écriture}

\begin{minted}{c}
int fprintf(FILE *f, const char *format, ...valeurs); // Écriture
int  fscanf(FILE *f, const char *format, ...adresses); // Lecture
char *fgets(char *s, int max, FILE *f); // Lecture d'une chaîne de caractères
char *fputs(char *s, FILE *f); // Écriture d'une chaîne
int   fgetc(FILE *f); // Lecture d'un caractère
int   fputc(FILE *f); // Écriture d'un caractère
\end{minted}

\subsection{Lecture d'une ligne complète}

\begin{minted}{c}
// La ligne est écrite dans ligne, sa taille est donnée dans n.
// On peut donner des éléments déjà initialisés, s'il peut les réutiliser il le fera,
// sinon il en alloue des nouveaux.
// Les caractères de fin de ligne sont inclus.
ssize_t getline (char **ligne, size_t *n, FILE *f);
\end{minted}

\part{C++}

\section{Classes}

\subsection{Syntaxe}

On prend l'exemple d'une classe {\tt Piece}.

\subsubsection{Déclaration}

\begin{minted}{cpp}
// Header
class Piece
{
    ...
}
\end{minted}

\subsubsection{Attributs et méthodes}

Elles sont déclarées dans le header:

\begin{minted}{cpp}
// Header
class Piece
{
private:
    int a;     // Attribut privé

public:
    Piece();   // Constructeur par défaut
    void do(); // Méthode publique
}
\end{minted}

Puis on peut les déclarer dans le fichier source:

\begin{minted}{cpp}
void Piece::do(){
    // ...
}
\end{minted}

\subsection{Constructeurs}

\subsubsection{Déclaration}

On peut déclarer un constructeur:

\begin{minted}{cpp}
// piece.h
Piece(...);                  // Remplacer ... par les paramètres
\end{minted}

Il est possible d'initialiser les champs de manière optimisée:
\begin{minted}{cpp}
// Header
class Piece
{
private:
    int x;
    int y;

public:
    Piece(int _x, int _y);
}

// piece.cpp
Piece::Piece(int _x, int _y):
x(_x), y(_y) {
    std::cout << "Création d'une pièce..." << std::endl;
}
\end{minted}

\subsubsection{Appel statique}

\begin{minted}{cpp}
Piece tmp(...);              // Appel statique
\end{minted}

\subsubsection{Appel dynamique}

\begin{minted}{cpp}
Piece *tmp = new Piece(...); // Appel dynamique, ne pas oublier de delete le pointeur !
delete tmp;                  // Comme ceci
\end{minted}

\subsubsection{Constructeur par défaut}

\paragraph{Génération automatique}
La version de base 

\subsubsection{Constructeur par copie\label{constructeur-copie}}

Pour la classe Piece, la constructeur par copie a pour signature:

\begin{minted}{cpp}
Piece::Piece(const Piece &autre);
\end{minted}

\paragraph{Génération automatique}

Il est généré par le compilateur quand il est absent. Attention: la version générée copie les champs, mais s'ils sont des pointeurs (eg. des \mintinline{c}{*char}), ceux-ci ne sont pas copiés (la copie n'est pas récursive).

Si on écrit le constructeur par copie à la main, il faut absolument réécrire aussi le destructeur et l'opérateur~`='~!

\paragraph{Empêcher l'existence du constructeur par copie}

Si on veut interdire l'utilisation du constructeur par copie, on peut le déclarer de cette manière:

\begin{minted}{cpp}
// Header
Piece(const Piece &autre) = delete;
\end{minted}

\paragraph{Surcharge}
Si on modifie le constructeur par copie, il faut nécessairement ajouter un destructeur \cf{destructeur} et l'opérateur `=' \cf{operator-equals}.

\subsection{Destructeur\label{destructeur}}

Le destructeur sert à ``rendre'' tout ce qui a été alloué dynamiquement.

Il s'écrit:
\begin{minted}{cpp}
// piece.h
class Piece{
public:
     Piece(); // Constructeur
    ~Piece(); // Destructeur
}
\end{minted}

\paragraph{Surcharge}
Attention, si vous l'écrivez vous-même, il faut aussi redéfinir le constructeur par copie \cf{constructeur-copie} et l'opérateur `=' \cf{operator-equals}.

\subsection{Opérateurs}

\subsubsection{Cas général}

On déclare une fonction :

\begin{minted}{cpp}
const int & Piece::operator[](int i);
\end{minted}

Puis on peut l'appeler:

\begin{minted}{cpp}
Piece tmp;
int a = tmp[0];
\end{minted}

\subsubsection{Opérateur =\label{operator-equals}}

On prend comme exemple une classe {\tt Piece}.

\begin{minted}{cpp}
// Header
Piece &operator=(const Piece &autre);

// Exemple d'implémentation

\end{minted}

\paragraph{Construction d'un nouveau objet}

Attention ! Dans l'exemple suivant, l'opérateur = \textbf{n'est pas} appelé:
\begin{minted}{cpp}
Piece p1();    // Constructeur par défaut
Piece p2 = p1; /* Pas d'appel de operator= !
                  C'est le constructeur par copie qui est appelé ! */
\end{minted}

\paragraph{Surcharge}
Attention, si vous modifiez cet opérateur, il faut nécessairement déclarer un destructeur \cf{destructeur} et un constructeur par copie \cf{constructeur-copie}.

\appendix % Annexes, ARTICLE & BOOK
\part{Annexes}

%\bibliography{•} % THE .BIB FILE HERE, WITHOUT THE EXTENSION
\printindex
\printglossaries

\end{document}
