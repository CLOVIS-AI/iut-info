\documentclass[10pt,a4paper,french]{article}
\usepackage{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{../latex/clovisai}

\makeindex
\makeglossaries

\glossaryentry{select}{SELECT}{}{Récupération de données}
\glossaryentry{from}{FROM}{}{Choisir la source}
\glossaryentry{distinct}{DISTINCT}{}{Résultats uniques sous MS SQL}
\glossaryentry{unique}{UNIQUE}{}{Résultats uniques sous Oracle}
\glossaryentry{where}{WHERE}{}{Appliquer une condition logique}
\glossaryentry{and}{AND}{}{Opérateur logique ET}
\glossaryentry{or}{OR}{}{Opérateur logique OU}
\glossaryentry{like}{LIKE}{}{Comparaison à un pattern}
\glossaryentry{in}{IN}{}{Choisir dans une liste}
\glossaryentry{between}{BETWEEN}{}{Choisir dans un intervalle}
\glossaryentry{is}{IS}{}{Est-ce qu'une valeur est nulle ?}
\glossaryentry{not}{NOT}{}{Négation}
\glossaryentry{null}{NULL}{}{Valeur nulle}
\glossaryentry{group}{GROUP BY}{}{Grouper des valeurs}
\glossaryentry{avg}{AVG}{}{Moyenne}
\glossaryentry{count}{COUNT}{}{Compter}
\glossaryentry{max}{MAX}{}{Maximum}
\glossaryentry{min}{MIN}{}{Minimum}
\glossaryentry{as}{AS}{}{Renommer une colonne ou une table (alias)}
\glossaryentry{commit}{COMMIT}{}{Valider une transaction}
\glossaryentry{rollback}{ROLLBACK}{}{Annuler une transaction}
\glossaryentry{delete}{DELETE}{}{Supprimer des données dans une table}
\glossaryentry{drop}{DROP}{}{Supprimer une table}
\glossaryentry{insert}{INSERT}{}{Ajouter des données dans une table}
\glossaryentry{update}{UPDATE}{}{Modifier une donnée dans une table}

\begin{document}

\title{Bases de données}
\author{Ivan Canet}
\maketitle

%\begin{abstract} % ARTICLE ONLY
%Ceci est l'introduction du document.
%\end{abstract}

\tableofcontents

\section{Requêtes}

\subsection{\gls{select}}

\subsubsection{\gls{select} \gls{from}}

Permet de récupérer les données.
\begin{minted}{sql}
SELECT [Champs]
FROM [Table]
\end{minted}

Par exemple, pour récupérer le nom et prénom de tous les abonnés, on écrit:
\begin{minted}{sql}
SELECT Nom, Prenom
FROM Abonnes
\end{minted}

On peut aussi utiliser une astérisque pour récupérer tous les champs:
\begin{minted}{sql}
SELECT *
FROM Abonnes
\end{minted}

\subsubsection{\gls{as}}

Permet de renommer une colonne dans le contexte de la requête (la table n'est pas modifiée).
\begin{minted}{sql}
SELECT Nom AS NomDeFamille
FROM Etudiants
\end{minted}

\subsubsection{\gls{distinct} / \gls{unique}}

Permet de supprimer les doublons ; exemple: lister les noms de famille:
\begin{minted}{sql}
SELECT DISTINCT Nom
FROM Abonnes
\end{minted}

\paragraph{Microsoft vs Oracle}
Sur MS SQL on utilise `\gls{distinct}', sur Oracle on utilise `\gls{unique}' à la place.

\subsubsection{\gls{where}}\label{where}

Permet de ne sélectionner qu'une partie de la base avec une condition logique.
\begin{minted}{sql}
WHERE [Condition]
\end{minted}

\paragraph{Opérateurs simples}
On peut utiliser `=' pour tester une égalité. Par exemple, pour avoir tous les étudiants qui s'appellent Martin:
\begin{minted}{sql}
SELECT Nom, Prenom
FROM Etudiants
WHERE Nom = 'Martin'
\end{minted}
De la même manière, on peut utiliser `!=', `$>$', `$<$', `$\leq$' et `$\geq$'.

\paragraph{Opérateurs logiques}
On peut utiliser `\gls{and}' et `\gls{or}' pour combiner les conditions:
\begin{minted}{sql}
SELECT Nom, Prenom
FROM Etudiants
WHERE Nom LIKE 'N%' OR Nom LIKE 'M%'
\end{minted}

\paragraph{Opérateur \gls{like}}
Permet de chercher pour une égalité vague; par exemple, la liste des étudiants dont le prénom commence par un `N':
\begin{minted}{sql}
SELECT Nom, Prenom
FROM Etudiants
WHERE Nom LIKE 'N%'
\end{minted}
Le \% représente ``n'importe quoi''.

\paragraph{Opérateur \gls{in}}
Permet de récupérer toutes les correspondances dans une liste. Par exemple, pour avoir les étudiants qui s'appellent `Martin', `Martine' ou `Pierre':
\begin{minted}{sql}
SELECT Nom, Prenom
FROM Etudiants
WHERE Nom IN ('Martin', 'Martine', 'Pierre')
\end{minted}

\paragraph{Opérateur \gls{between}}
Permet d'avoir les valeurs dans un intervalle, par exemple, les étudiants qui sont nés entre le 1 janvier 1998 et le 31 décembre 1998:
\begin{minted}{sql}
SELECT Nom, Prenom
FROM Etudiants
WHERE (DateNaissance BETWEEN '1998-01-01' AND '1998-12-31')
\end{minted}
Attention: certaines bases de données incluent les bornes, d'autres ne les incluent pas.

\paragraph{Opérateur \gls{is} \gls{null}}
Pour savoir si une case est vide, on peut utiliser `IS NULL':
\begin{minted}{sql}
SELECT Nom, Prenom
FROM Etudiants
WHERE Nom IS NOT NULL
\end{minted}

\paragraph{Opérateur \gls{not}}
Permet de faire la négation d'une condition. On peut l'utiliser avec `\gls{is} \gls{null}', avec `\gls{between}', avec `\gls{in}' et avec `\gls{like}'.

\subsubsection{\gls{group}}

Grouper des résultats. Exemple: dans une table qui contient toutes les notes des étudiants, grouper les notes par étudiant pour obtenir leur moyenne (\gls{avg} permet de faire la moyenne):
\begin{minted}{sql}
SELECT Nom, Prenom, AVG(Note)
FROM Notes
GROUP BY Nom, Prenom
\end{minted}
La clause du \gls{group} doit être dans le \gls{select}!

\subsubsection{HAVING}

\subsubsection{UNION / INTERSECT / EXCEPT}

\subsubsection{ORDER BY}

\subsubsection{LIMIT}

\subsubsection{OFFSET}

\subsection{Agrégations}

Les agrégations permettent de regrouper plusieurs lignes en une seule; par exemple en faisant la somme des lignes, ou alors simplement en les comptant.

Il faut toujours utiliser \gls{as}.

\subsubsection{\gls{count}}
Compter le nombre de lignes.
\begin{minted}{sql}
SELECT COUNT(*) AS Nombre
FROM Etudiants
\end{minted}

\subsubsection{\gls{avg}}
Permet de faire la moyenne d'une colonne.
\begin{minted}{sql}
SELECT AVG(Note) AS Moyenne
FROM Notes
\end{minted}

\subsubsection{\gls{min} et \gls{max}}
Trouver le minimum ou le maximum d'une colonne. Exemple: trouver la meilleure note:
\begin{minted}{sql}
SELECT MAX(Note) AS Note
FROM Notes
\end{minted}

\subsection{\gls{delete}}

Permet de supprimer des données dans une table:
\begin{minted}{sql}
DELETE FROM Users          -- La table est maintenant vide
\end{minted}

\gls{delete} est compatible avec \gls{where} \cf{where}:
\begin{minted}{sql}
DELETE FROM Users          -- Suppression de tous les utilisateurs
WHERE Users.Name LIKE 'E%' -- dont le nom commence par un E
\end{minted}

\subsection{\gls{drop}}

\subsection{\gls{insert}}\label{insert}

Ajouter des données dans une table.

Avec la première syntaxe, on doit remplir toutes les colonnes \textit{dans l'ordre}.
\begin{minted}{sql}
INSERT INTO Users
VALUES ('Nom', 'Prenom')
\end{minted}

La deuxième syntaxe permet de choisir quelles données donner (pour ne pas remplir les données facultatives, on peut choisir l'ordre):
\begin{minted}{sql}
INSERT INTO Users (Prenom, Nom)
VALUES ('Olivier', 'Guibert')
\end{minted}

\subsection{\gls{update}}\label{update}

\section{Procédures}

\section{Transactions et sessions}

Une session représente une ``connexion'' à la base de données.

Une transaction consiste en un certain nombre de requêtes qui sont ``groupées'' pour former un tout. Au fur et à mesure, les requêtes contenues sont simulées: leur résultat est visible dans la session courante, mais pas pour les autres.

Sous Oracle DB, chaque requête est un début de transaction.

\paragraph{Propriétés ACID}
Les transactions ont des propriétés:
\begin{itemize}
\item Atomicité: elle est indivisible,
\item Cohérence: les contraintes d'intégrité sont respectées,
\item Isolation: les transactions n'influent pas les unes sur les autres,
\item Durabilité: tout est enregistré, même après une déconnexion.
\end{itemize}

\paragraph{Terminer une transaction}
On peut valider une transaction avec \gls{commit}: toutes les requêtes sont effectuées dans la vraie base de données.

On peut annuler une transaction avec \gls{rollback}: les requêtes ne sont pas transmises à la base de données, elle n'est donc pas modifiée.

\paragraph{Transactions bloquantes}
Quand une transaction modifie la base de données, elle devient ``bloquante'': les autres transactions (dans d'autres sessions) ne peuvent plus accéder aux tables modifiées. Elles doivent donc attendre que la première soit terminée (validée ou annuler), avant de pouvoir s'exécuter.

Il faut donc faire des transactions courtes, pour ne pas bloquer le système.

Cas bloquants et non-bloquants:
\begin{itemize}
\item La lecture seule n'est jamais bloquante,
\item L'ajout de données dans une table est bloquant, \hfill \cf{insert}
\item La modification d'une donnée dans une table est bloquant, mais uniquement pour cette donnée (le reste de la table n'est pas bloqué). \hfill \cf{update}
\end{itemize}
Si deux transactions s'attendent mutuellement, la base de données en débloque une des deux avec une erreur ``deadlock detected''. Sa dernière action (celle qui était bloquante) est donc perdue, mais pas les précédentes.

\appendix % Annexes, ARTICLE & BOOK

%\bibliography{•} % THE .BIB FILE HERE, WITHOUT THE EXTENSION
%\cprintindex
\printglossaries

\end{document}
