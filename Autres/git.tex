\documentclass[10pt,a4paper]{article}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{../latex/clovisai}

\begin{document}

\title{Utiliser Git}
\author{Ivan Canet}
\maketitle
\begin{abstract}
Git est un système de versionnage -- il va gérer tous vos projets à l'IUT, pour pouvoir travailler à plusieurs, organiser votre travail, etc.

Vous allez l'utiliser toute votre carrière, et vous devez absolument en connaître les bases (à défaut de le maîtriser).

Ce document n'a pas vocation à présenter tous les détails de Git, mais à montrer ce qui va être utilisé tous les jours.
\end{abstract}

\tableofcontents

\part{Les bases de Git}

\section{Introduction}

Quels sont les avantages d'un système de version?

\begin{itemize}
\item Travailler à plusieurs sur un projet
\item Ne jamais perdre de code
\item Revenir à d'anciennes versions
\item Travailler dans une branche pour faire des essais
\end{itemize}

Pourquoi apprendre Git en particulier?

\begin{itemize}
\item C'est celui le plus utilisé
\item Gratuit \& Open Source
\item Très performant
\item Vous l'utiliserez toute votre vie!
\end{itemize}

La raison de lire ce document? Sur votre temps à l'IUT, une `initiation' à Git est prévue sur 2 heures. Ce n'est absolument pas assez pour comprendre les concepts, et surtout, vous pouvez revenir ici dès que vous en avez besoin!

Commençons par installer Git.

\section{Préparation de Git}

\subsection{Installation}

\paragraph{Sous Linux}

Il suffit d'effectuer la commande:

\begin{minted}{bash}
sudo apt-get install git
\end{minted}

Je vous conseille aussi d'installer le packet {\tt bash-completion} (pour avoir l'auto-complétion). Il est installé par défaut sur plusieurs Linux.

\begin{minted}{bash}
sudo apt-get install bash-completion
\end{minted}

\paragraph{Sous Windows}

Vous pouvez télécharger Git Bash. Ce n'est pas le seul moyen d'avoir Git sur Windows, mais c'est celui utilisé à l'IUT.

\subsection{Configuration\label{config}}

Oui je sais, ce n'est pas intéressant de faire de la configuration. Mais croyez-moi, cela va vous éviter de très nombreux problèmes.

\subsubsection{Identité}

La première étape est obligatoire, elle permet à Git de vous connaître (c'est votre identité).

\begin{minted}{bash}
git config --global user.name 'Votre Nom Ici'
git config --global user.email 'votre.addresse@etu.u-bordeaux.fr'
\end{minted}

On utilise la commande \mintinline{bash}{git config} avec l'option {\tt global} qui permet de le donner comme configuration globale à votre ordinateur. Vous pouvez enlever cette option pour avoir une configuration différente d'un projet à l'autre (mais ça ne vous servira probablement pas au sein de l'IUT).

\subsubsection{Utilisation des alias\label{alias}}

Une commande qui peut vous servir souvent:

\begin{minted}{bash}
git config --global alias.NOM 'COMMANDE'
\end{minted}

Cette commande vous permet de créer un alias (un raccourci). Comme cela, vous pouvez faire des abréviations pour vos commandes. Par exemple:

\begin{minted}{bash}
git config --global alias.ca 'commit -a'
\end{minted}

vous permet d'utiliser la commande ``\mintinline{bash}{git ca}'' au lieu de ``\mintinline{bash}{git commit -a}''.

Vous pouvez faire vos propres alias vous-même, mais je vous en conseille quelques-un qui vous serons très pratiques:

\begin{minted}{bash}
# Liste des alias disponibles
git config --global alias.aliases "config --get-regexp '^alias\.'"

# Abréviations
git config --global alias.st 'status'
git config --global alias.co 'checkout'
git config --global alias.a 'add'
git config --global alias.c 'commit'
git config --global alias.cm 'commit -m' # Inclue le message
git config --global alias.p 'pull -p' # Supprime branches locales
git config --global alias.ps 'push'
git config --global alias.f 'fetch -p' # Supprime branches locales

# Liste des tags
git config --global alias.tags 'tag -l -n1 --sort=taggerdate'

# Joli affichage de l'historique
git config --global alias.glog "log --graph --oneline --decorate=short --branches='*'"
\end{minted}

Maintenant, vous pouvez utiliser:

\begin{minted}{bash}
git aliases # Liste des alias
git tags # Liste des tags dans l'ordre chronologique
git p # Pull
git glog # Affichage de l'historique
git glog -10 # Affichage des 10 derniers commits
\end{minted}

\subsubsection{Autres configurations}

Voici d'autres configurations que nous vous conseillons.

\begin{minted}{bash}
# Pousser uniquement la branche actuelle lors de git push
git config --global push.default simple
\end{minted}

\paragraph{Spécial Linux}

\begin{minted}{bash}
# Nano au lieu de VIM (pour ceux qui ne veulent pas apprendre VIM)
git config --global core.editor nano
# Utilisation des fins de lignes LF (défaut sous Linux)
git config --global core.autocrlf input
\end{minted}

\paragraph{Spécial Windows}

\begin{minted}{bash}
# Bloc-note au lieu de VIM
# (pour ceux qui ne veulent pas apprendre VIM)
git config --global core.editor notepad
# Conversion des CRLF en LF en interne, conversion inverse en sortie
git config --global core.autocrlf input
\end{minted}

La ligne 5 (conversion CRLF) est très importante si vous travaillez à la fois sur des ordinateurs Linux \& Windows, puisque Linux utilise LF comme fin de ligne et Windows utilise CRLF. De cette manière, tous les CRLF seront transformés en LF en interne, et la version partagée ne contiendra que des LF ; mais en local, votre ordinateur continue d'utiliser CRLF.

\section{Création du projet}

Git permet de stocker des projets. En deux mots, Git permet d'enregistrer des versions d'un dossier (et de tous les fichiers qu'il contient). Pour cela, Git ajoute un dossier caché à votre projet, le {\tt .git}. C'est lui qui contient l'historique du projet, etc. Vous n'aurez JAMAIS besoin d'y toucher! C'est même d'ailleurs une bonne habitude: habituez-vous à le laisser tranquille.

Quand le projet est créé, il est contenu dans un dossier (que nous appellerons "racine du projet"). Vous pouvez le déplacer, le renommer, etc, cela n'a absolument aucun impact sur votre projet. Voici un schéma de la structure du projet:

\begin{minted}[linenos=false]{bash}
racine/
  fichier1.txt
  sousdossier/
    fichier2.txt
  .git/
\end{minted}

Tout ce qu'il y a à savoir, c'est que Git ne connaît que le contenu du dossier qui contient le {\tt .git} (la racine du projet). Le dossier "racine" peut être déplacé ou renommé sans problèmes, seul son contenu est pris en compte.

Voyons voir comment créer ce fameux {\tt .git} !

\subsection{Création d'un nouveau projet}

Vous aurez très rarement besoin de créer un nouveau projet vous-même. Dans le cas où vous en auriez besoin, Git propose une très simple commande pour cela:

\begin{minted}{bash}
git init
\end{minted}

En réalité, ce qui va souvent arriver, c'est que vous créerez le projet via un site comme GitLab ou GitHub, puis vous en ferez une copie sur votre PC. Voyons comment le faire.

\subsection{Récupération d'un projet existant}

Dans le cas où le projet Git existe déjà (créé par GitLab, GitHub ou un coéquipier) et que vous voulez y accéder, il vous faut une copie locale. On appelle cela un clone.

La syntaxe globale est:

\begin{minted}{bash}
git clone ADRESSE ENDROIT
\end{minted}

où {\tt ADRESSE} correspond à l'endroit ou se trouve le fichier, et {\tt ENDROIT} correspond à l'endroit où vous voulez cloner le projet (doit être un dossier vide, par défaut le dossier actuel).

Il existe de nombreuses manières d'écrire l’adresse. Détaillons-les.

\subsubsection[Différents protocoles]{Différents protocoles pour récupérer le projet}

\paragraph{Local} Vous pouvez cloner un projet directement depuis un autre projet sur votre ordinateur. C'est bon à savoir mais ce n'est quasiment jamais utilisé, c'est juste un bon exemple... Pensez à bien sélectionner le {\tt .git} !

\begin{minted}{bash}
# Exemple
git clone ~/Documents/.../.git
\end{minted}

\paragraph{HTTPS}

Le protocole HTTPS est utilisé par GitLab et GitHub. Il ne nécessite pas de configuration, par contre votre nom d'utilisateur et votre mot de passe vous serons demandés à chaque connexion au serveur.

\begin{minted}{bash}
# Exemple
git clone https://gitlab-ce.iut.u-bordeaux.fr/icanet/iut-info.git
\end{minted}

\paragraph{SSH}

Le protocole SSH est aussi utilisé par GitLab et GitHub. Il est beaucoup plus sécurisé et ne nécessite pas de mot de passe. Pour l'utiliser, vous devez générer une clef SSH et l'ajouter à votre compte GitHub / GitLab\footnote{Les étapes sont expliquées sur GitLab, allez en haut à droite dans votre compte, Paramètres, Clés SSH.}.

\begin{minted}{bash}
# Exemple
git clone git@gitlab-ce.iut.u-bordeaux.fr:icanet/iut-info.git
\end{minted}

\paragraph{Git}

Le protocole Git est très peu utilisé et n'est pas décrit ici.

\subsubsection{Que se passe-t-il exactement quand on clone le projet~?}

Quand on clone un projet, Git crée une copie de la version actuelle du projet sur le serveur dans votre dossier local, et se souvient de comment se connecter au serveur. Nous reviendrons là-dessus plus en détail quand nous évoquerons les branches (voir page \pageref{branches}).

\subsection{Paramétrage du projet}

Avoir le projet, c'est bien, mais il faut aussi le paramétrer !

Cela se produit en général en trois étapes principales, le {\tt README}, la licence, et le {\tt .gitignore}.

C'est très souvent la responsabilité de la personne qui crée le projet -- mais ça ne veut pas dire qu'il faut le négliger!

\subsubsection{Le fichier README}

Le fichier {\tt README.md} doit être placé à la racine de votre projet. Il a pour but d'expliquer à vos coéquipiers comment le projet fonctionne (il n'est absolument pas obligatoire, mais en pratique il est toujours utile).

\subsubsection{La licence}

La licence du projet détermine qui peut faire quoi avec votre projet. Pour un projet privé, elle n'est pas importante -- mais les profs aiment beaucoup qu'elle soit spécifiée, et vu que ça ne prend que quelques minutes !

Elle se situe traditionnellement dans le fichier {\tt LICENSE} à la racine du projet. La liste des licences les plus utilisées est disponible sur \href{https://choosealicense.com/}{choosealicense.com} (en anglais).

\subsubsection{Le .gitignore\label{gitignore}}

Le {\tt .gitignore} est le fichier le plus important de toute la configuration. Si vous oubliez de le mettre vous risquez des énormes conflits quand vous travaillerez à plusieurs !

Il a pour but premier de rendre le projet le plus léger possible en disant à Git quels fichiers ne vous intéressent pas. Par exemple, sous NetBeans, le dossier {\tt /build} dans le projet contient le code compilé. Ça ne sert à rien de l'avoir dans le Git, puisque NetBeans peut le reconstruire à la demande !

Le second but du {\tt .gitignore} est d'éviter au maximum les conflits entre coéquipiers. Par exemple, les fichiers de configuration de NetBeans situés dans /nbproject/private sont différents pour chaque personne... si vous le partagez, vous allez casser la configuration de vos coéquipiers (ou la votre sur un autre ordinateur) !

Par contre, les fichiers /nbproject/project.xml et /nbproject/project.properties sont importants puisque sans eux, NetBeans n'arrive plus à reconnaître le projet, il ne faut donc pas les ignorer.

Voici le {\tt .gitignore} pour un projet sous NetBeans :

\begin{minted}{bash}
# Exécutables
build/
dist/

# Fichiers
*.xml
*.properties
!build.xml

# Configuration
nbproject/
!nbproject/project.xml
!nbproject/project.properties
\end{minted}

Ce fichier doit être placé à la racine du projet NetBeans (pas à la racine du projet Git\footnote{Vous pouvez avoir plusieurs {\tt .gitignore} à différents endroits de votre projet si vous le voulez, mais celui-ci à été écrit pour être placé à la racine du projet NetBeans (les chemins sont relatifs).} !) et doit s'appeler {\tt .gitignore} (sans extension)\footnote{Windows gère mal les fichiers n'ayant pas d'extensions. Pour en créer un sur Windows, créez un fichier normal `fichier.txt' puis renommez-le, par exemple en utilisant ``{\tt rn fichier.txt .gitignore}'' avec Batch ou ``{\tt mv fichier.txt .gitignore}'' avec la console Git Bash.}.

Le point d'exclamation signifie une négation : on ne veut pas les fichiers {\tt XML}, SAUF le fichier {\tt build.xml} (lignes 6 et 8).

\paragraph{Que faire en cas d'oubli~?\label{oubli-gitiginore}}

Le fichier {\tt .gitignore} n'est pas rétroactif ! Si vous l'ajoutez APRÈS avoir ajouté un fichier au projet, ce fichier ne sera pas ignoré, même s'il est contenu dans le {\tt .gitignore}.

Dans ce cas, vous devez dire à Git que le(s) fichier(s) que vous voulez ignorer sont supprimés. Il y a deux méthodes:

\begin{itemize}
\item Supprimer les fichiers du projet complètement:% sans --cached

\begin{minted}{bash}
git rm FICHIERS
\end{minted}

\item Supprimer les fichiers de Git, mais les garder localement (ils sont supprimés de l'historique mais pas du projet):% avec --cached

\begin{minted}{bash}
git rm --cached FICHIERS
\end{minted}
\end{itemize}

\section{Synchronisation}

Comme nous l'avons dit plus haut, Git est système distribué. Dans les faits, cela signifie que chaque personne a une copie complète du projet. Si la version du serveur est corrompue pour une raison ou pour une autre (pas besoin de vous inquiéter, ça n'arrive jamais~!), n'importe quelle personne ayant cloné le projet peut la republier. Si vous supprimez votre dossier accidentellement (ça par contre ça arrive), vous pouvez redemander au serveur sa version. Vos modifications non-synchronisées sont perdues, mais pas le projet entier !

En fait, quand vous allez travailler sur le projet, vous n'allez pas travailler \textit{sur la version du serveur} mais \textit{sur votre propre version} (on appelle ça une branche, on en reparlera beaucoup plus en détails plus tard).

C'est une distinction importante à comprendre: quand vous modifiez un fichier, la modification n'est PAS envoyée en serveur en direct (contrairement à Google Drive par exemple). Voici pourquoi ce choix n'a pas été fait:

\begin{itemize}
\item Git a été créé quand les connexions internets étaient très mauvaises, ce n'était pas possible de synchroniser en direct
\item Des ancêtres de Git fonctionnaient sans copie (Perforce \& CVS, par exemple): on travaillait directement sur la version du serveur. Un des résultat était que deux personnes ne pouvaient pas travailler sur le même fichier en même temps... Alors qu'avec Git, aucun problème.
\end{itemize}

Il est donc important de savoir se synchroniser avec le serveur, puisque ça ne se fait pas tout seul !

Petite note avant de continuer, on dit ``se synchroniser avec le serveur'', mais en soit, vous pouvez vous synchroniser avec n'importe qui. C'est juste que souvent, on aime bien tout regrouper à un seul endroit.

\subsection{Envoyer la copie locale au serveur}

Imaginez que vous ayez fait une amélioration de votre projet. Vous voulez envoyer vos modifications au serveur.

La version locale et la version du serveur sont différentes, mais la votre est meilleure.
Nous allons donc l'envoyer au serveur.

\begin{minted}{bash}
git push
\end{minted}

Vous avez cloné le projet depuis un serveur, Git se ``souvient'' quelle était son adresse.

Attention cependant, cela ne va fonctionner que s'il n'y a pas de conflit. Qu'est-ce qu'un conflit? Quand vous envoyez votre version au serveur, il existe plusieurs situations:

\begin{itemize}
\item Vous avez des modifications en avance sur le serveur: pas de problème, votre version est plus récente donc le serveur mets à jour sa version pour qu'elle soit identique à la votre.
\item Vous avez divergé: cela arrive si le serveur a été modifié depuis votre dernière synchronisation. Dans ce cas-là, le serveur est bloqué; s'il prend votre version, ses modifications sont perdues, et s'il prend sa version, vos modifications sont perdues. Le serveur va alors rejeter votre envoi (vous aurez un message du genre ``push rejected, fetch first''). Dans ce cas, continuez à lire.
\end{itemize}

\subsection{Récupérer la copie du serveur}

De temps en temps, vous voudrez vous remettre à jour par rapport au serveur (par exemple pour récupérer le travail de vos coéquipiers).

Cela se passe en deux étapes, il faut d'abord récupérer l'historique des modifications, puis les appliquer à votre version.

\begin{minted}{bash}
git fetch
\end{minted}

Cette commande permet de récupérer les modifications présentes sur le serveur, mais ne va pas les appliquer! Votre copie locale n'est absolument pas modifiée. Vous pouvez donc le faire aussi souvent que vous le voulez.

On a vu la première étape, mais je ne vais pas vous montrer comment appliquer les modifications. Pourquoi, parce que c'est une commande compliquée que vous n'avez pas besoin de connaître, et parce qu'il existe une commande magique qui fait les deux étapes en même temps!

\begin{minted}{bash}
git pull
\end{minted}

Cette commande est un raccourci pour ``git fetch'' + la commande que je ne vous ai pas montré. En pratique, c'est toujours elle que l'on va utiliser, mais il est bon de connaître l'existence de fetch.

Dans certains cas par contre, cela ne va pas marcher! Quels sont ces cas?

\begin{itemize}
\item Si votre version est en avance sur la version du serveur: il ne se passe rien, puisque vous avez déjà toutes les modifications présentes sur le serveur!
\item Si votre version est en retard sur la version du serveur: votre version locale est remplacée par celle du serveur, et maintenant votre version est identique à celle du serveur!
\item Si vos versions ont divergé, on dit qu'il y a conflit. Voyons comment régler les conflits.
\end{itemize}

\subsubsection{Régler les conflits\label{régler-conflits}}

Lors d'un conflit, Git va essayer de le régler tout seul, comme un grand. Il fait ça en observant les modifications des deux versions (la votre et celle du serveur). Il y a alors deux cas:

\begin{itemize}
\item Si toutes les modifications sont dans des fichiers différents, ou même des lignes différentes dans un même fichier, Git fusionne les deux versions tout seul.
\item Si une même ligne (ou un groupe de même lignes) a été modifiée par les deux personnes, Git est incapable de choisir la meilleure version : il plante et vous demande votre avis.

Si cela arrive, Git vous donne la liste des fichiers dans lequel des conflits non-résolus existent encore, puis s'arrête. Vous pouvez aussi récupérer cette liste via ``git status'', ils apparaissent avec la mention ``both modified'' (on en reparlera plus tard).

Vous devez alors aller vous-même régler les conflits. C'est très simple: dans les fichiers concernés, Git a ``marqué'' les parties conflictuelles. Illustrons la situation avec un exemple:

Imaginons que vous avez créé un fichier ``animaux.txt'' qui contient une liste d'animaux:

\begin{minted}{text}
vache
poule
mouton
//autre chose
\end{minted}

Vous avez envoyé ce fichier au serveur avec ``git push'' sans problèmes. Maintenant vous vous dites qu'il serait mieux au pluriel. Vous ajoutez donc un `s' à chaque animal, votre fichier est maintenant:

\begin{minted}{text}
vaches
poules
moutons
//autre chose
\end{minted}

Jusque-là tout va bien, mais entre-temps, Fred a aussi modifié le fichier, il a ajouté les pigeons!

Voici la version de Fred:

\begin{minted}{text}
vache
poule
mouton
pigeon
//autre chose
\end{minted}

Comme Fred a déjà envoyé sa version au serveur, le serveur refuse que vous envoyiez la votre, et annonce qu'on conflit est présent. Git vous a marqué le conflit: vous allez trouver le fichier ressemblant à quelque chose comme cela:

\begin{minted}{text}
<<<<<<<<< HEAD
vaches
poules
moutons
=========
vache
poule
mouton
pigeon
>>>>>>>>> 153de48dzd15fe
//autre chose
\end{minted}

Cela mérite de faire une pause pour bien expliquer ce qu'il se passe. Git a trouvé deux versions du fichier et ne sait pas comment les fusionner. Donc il vous demande votre avis, en vous donnant les premières versions. Il délimite le début d'un conflit avec ``<'' et la fin avec ``>''. Au début, il affiche ``HEAD'', cela veut dire ``votre version''\footnote{Plus de détails page \pageref{head}, \textit{\nameref{head}}.}. À la fin, il affiche un nombre en hexadécimal, c'est l'identifiant de la modification de Fred\footnote{Plus de détails page \pageref{commit}, \textit{\nameref{commit}}.}. Les deux versions sont séparées par des ``=''.

Pour régler le conflit, il suffit de corriger le fichier pour qu'il redevienne normal. Vous pouvez faire ce que vous voulez: prendre votre version et abandonner celle de Fred, prendre celle de Fred et abandonner la votre, ou faire un mélange des deux. Comme Fred est votre ami, vous allez bien faire et tout fusionner. Le résultat ressemble à ça:

\begin{minted}{text}
vaches
poules
moutons
pigeons
//autre chose
\end{minted}

On a bien ajouté le pigeon, et tout est au pluriel. C'est bon, le conflit est réglé!
\end{itemize}

Maintenant que vous savez comment régler les conflits, il faut officialiser le fin du conflit. Pour ce faire, faites simplement un nouveau commit (si le conflit a été réglé automatiquement, Git va directement ouvrir votre éditeur et demander un message) (vous ne savez pas le faire? Ça tombe bien, c'est le chapitre suivant!).

\paragraph{Cas particuliers: fins de lignes \& permissions}
Avant de passer à la suite, il est important de noter quelques cas particuliers. Git gère mal les conflits de permissions (lecture-écriture-exécution) ou de changement de fin de lignes (CRLF sous Windows, LF sous Linux et CR sous MacOS). Dans ce cas, Git peut vous mettre le fichier entier conflictuel et vous devrez parcourir vous-même le fichier entier. C'est extrêmement rébarbatif donc assurez-vous que votre Git soit bien configuré (cf.~\textit{\nameref{config}}, page \pageref{config}) et de ne modifier les permissions que si vous êtes sûrs que c'est nécessaire (je veux dire, pas une fois tous les deux jours).

\section{Enregistrements}

Il est temps de faire des modifications à votre projet pour de vrai!

En fait, quand vous allez envoyer / recevoir des informations du / au serveur, vous n'allez pas lui envoyer tous vos fichiers. Il est temps de détailler la partie la plus importante de Git: l'officialisation des modifications -- on appelle ça un commit.

\subsection{Staged et Unstaged\label{staged-unstaged}}

Avant de parler des commits eux-même, il faut évoquer la manière dont Git comprend le projet. Votre projet (local) contient deux parties: les fichiers, et l'historique (contenu dans le {\tt .git}). À n'importe quel moment, vous allez pouvoir dire ``je veux que la version actuelle du projet soit ajoutée à l'historique''.

Mais vous pouvez être intéressé par le fait de choisir quels fichiers vont faire partie de votre prochaine version ou non. Peut-être qu'un fichier est prêt, un autre non.

Un fichier peut donc être dans trois `états' du point de vue de Git:

\begin{itemize}
\item Ignoré: Git ne fait même pas attention à l'existence du fichier, le plus souvent parce que le fichier est inclus dans un fichier ``.gitignore'' (voir page \pageref{gitignore}).
\item Unstaged: Git sait que le fichier a été créé, mais ne le prend pas en compte.
\item Staged: La version actuelle du fichier sera incluse dans votre prochaine modification.
\end{itemize}

Vous pouvez savoir quel est le statut de chaque fichier en utilisant ``git status'', qui liste aussi les commandes pour passer un fichier d'un état à un autre. Listons-les ici.

\begin{itemize}
\item Unstaged $\rightarrow$ Staged: \mintinline{bash}{git add FICHIERS}\footnote{Vous pouvez aussi utiliser {\tt git add .} pour ajouter tous les fichiers, mais je vous conseille de le faire uniquement si vous êtes sûr de vous, vous risquez d'ajouter quelque chose que vous ne voulez pas ajouter.}
\item Staged $\rightarrow$ Unstaged: \mintinline{bash}{git checkout -- FICHIERS}
\item Ignoré $\rightarrow$ Staged: \mintinline{bash}{git add -f FICHIERS}, mais vous l'utiliserez très rarement, si vous l'avez ignoré ce n'est pas pour rien
\item Staged $\rightarrow$ Ignoré: voir \ref{oubli-gitiginore} \textit{\nameref{oubli-gitiginore},} page \pageref{oubli-gitiginore}.
\end{itemize}

Il existe de nombreuses autres commandes qui permettent en rapport avec l'état des fichiers. Par exemple, vous pouvez demander à Git de vous montrer tout ce qui a été modifié dans les fichiers Unstaged avec {\tt git diff} (vous pouvez aussi donner des noms de fichiers pour ne voir que ceux-ci).

\subsection{Commit\label{commit}}

Qu'est-ce qu'une mise à jour sous Git?

Simplement dit, c'est une capture de l'état (complet ou partiel) du projet à un moment donné.

C'est comme cela que l'on ``officialise'' une modification sous Git -- un commit a un auteur, une date, et un contenu.

Vous pouvez créer un commit avec:

\begin{minted}{bash}
git commit
\end{minted}

L'auteur du commit, c'est vous. La date et l'heure, Git la mets automatiquement. Le contenu, c'est l'ensemble des fichiers ``Staged'' (en vert dans {\tt git status}), ils sont chacun représentés par leur chemin relatif (à partir de la racine du projet), leur mode (permissions) et leur contenu. Un commit contient aussi un message. Quand vous effectuez la commande précédente, Git ouvre votre éditeur et vous demande un message. Pour gagner du temps, vous pouvez aussi donner le message directement:

\begin{minted}{bash}
git commit -m 'Votre message'
\end{minted}

Pour gagner du temps, vous pouvez aussi choisir directement quels fichiers vous voulez ajouter:\footnote{Ou \mintinline{bash}{git commit -am 'Votre message'} pour choisir tous les fichiers.}

\begin{minted}{bash}
git commit -m 'Votre message' -- FICHIERS
\end{minted}

C'est l'équivalent de:

\begin{minted}{bash}
git add FICHIERS
git commit -m 'Votre message'
\end{minted}

À propos du message... je sais que c'est tentant de mettre un truc à la con, mais je le déconseille fortement. La première ligne du message doit décrire précisément ce qui a été modifié dans le projet, avec un phrase courte au passé. Par exemple ``réglé bug où l'utilisateur ne pouvait plus se déconnecter''. Il est important que le message soit court et clair. Si vous voulez ajouter plus de détails, vous pouvez le faire à partir de la 3\ieme~ligne.

C'est bon, vous pouvez {\tt pull} et {\tt push} vos commits! Vous connaissez enfin les bases complètes de Git! Il est temps d'un gros résumé.

\section{Résumé: le workflow}

Résumons toutes les étapes de l'utilisation de Git.

\begin{itemize}
\item Installation de Git et paramétrage (alias et config...)
\item Création du projet et paramétrage (.gitignore...)
\end{itemize}

La journée de travail typique ressemble à:

\begin{minted}{bash}
git pull # le matin
# Faire des modifs
git add MODIFS
git commit -m 'Message'
# Retourner ligne 2 autant de fois que nécessaire
git push # À la fin quand tous les problèmes sont réglés
\end{minted}

J'insiste bien, ne {\tt git push} jamais si votre code ne compile pas! Sinon, votre coéquipier va devoir régler des conflits dans un code qui ne marche pas...

Prenez aussi l'habitude de faire des commits souvent. Ça fait pas de mal et c'est plus pratique, à la fois pour comprendre ce que les autres ont fait, mais aussi pour régler les conflits.

Et surtout, n'oubliez pas de {\tt push} quand vous avez fini. Presque à chaque séance de projet, il y a toujours quelqu'un dans la salle qui a oublié de push, du coup le groupe est coincé à devoir refaire ce qui a déjà été fait. C'est dommage.

\section{Depuis un IDE}

Personnellement, je préfère faire la majorité de mon travail en commandes, mais certaines personnes préfèrent utiliser un IDE. Voici comment réaliser directement dans l'IDE les tâches les plus simples (commits, push et pull).

\subsection{NetBeans}

Dans l'arbre des fichiers, vous pouvez:

\begin{itemize}
\item Faire un commit pour un fichier: clic-droit sur le fichier, Git, Commit file.
\item Faire un commit pour plusieurs fichiers: clic-droit sur un dossier, Git, Commit, puis sélectionner les fichiers.
\end{itemize}

\subsection{IntelliJ}

\subsection{Visual Studio}

\subsection{Atom}

\part{Travailler avec des branches\label{branches}}

Jusque-là, vous avez découvert la manière d'utiliser Git de base. Cela vous sera probablement suffisant ici à l'IUT, mais je vous déconseille de vous arrêter là. Oui, vous savez \textit{utiliser} Git, mais vous n'en profitez pas.

Pourquoi continuer à lire?
\begin{itemize}
\item Les branches permettent d'utiliser Git de manière beaucoup plus coopérative et efficace.
\item Vous aurez beaucoup, beaucoup moins de conflits. Croyez-moi.
\end{itemize}

\section{Qu'est-ce qu'une branche ?}

Avant de pouvoir commencer à les utiliser, il faut comprendre ce qu'elles sont.

Comme vous l'avez vu précédemment, Git gère le projet par ``commits''. Un commit, c'est une ``capture de l'état d'un projet à un instant donné'' -- c'est-à-dire la date, l'auteur, et le contenu des fichiers.

\subsection{Introduction}

Si vous effectuez \mintinline{bash}{git log --graph --oneline --decorate=short}, vous verrez l'historique du projet. Si c'est un projet qui existe depuis longtemps, il y a probablement eu des conflits ; dans ce cas, vous verrez quelque chose comme ça:

\begin{minted}{bash}
* ce23c9f Préparation pour le HTML
*   753fb53 Merge branch 'master'
|\  
| * ad6bfcb Message plus précis: pas besoin d issue si on fait une MR
| *   5490b8e Typo 'acceuil' dans README
| |\  
| | * 2068086 Erreur pas jolie Bravo
| |/  
* | 9aa09e2 Added .idea/ to .gitignore
|/  
* 2a5d7a8 Mise à jour du README
* bd95463 Cours du 15 juin 2018
\end{minted}

Ici, chaque ligne est un commit. On voit bien que les commits ont un ``enbranchement'' à la ligne 11 et à la ligne 8, et que les branches ``fusionnent'' à la ligne 5 et à la ligne 2.

Dans cet, exemple, 3 branches ont existé. Par convention, la branche principale s'appelle ``master''\footnote{Elle est créée automatiquement par Git avec ce nom lors de la création du projet. Rien ne vous empêche de la renommer ou de la supprimer, mais c'est déconseillé parce que tout le monde a pris l'habitude qu'elle s'appelle comme ça.}, c'est celle la plus à gauche. Les deux autres sont des branches temporaires, qui ont étés supprimées depuis (quand elles ont été fusionnées)\footnote{Fusionner une branche ne la supprime pas, plus de détails sur la fusion sont donnés page \pageref{end-branch}, ``\nameref{end-branch}''.}.

Avant de continuer, revenons aux commits eux-même.

\subsection{Approfondissement des commits}

Comme vous l'avez vu, chaque commit est identifié par un numéro en Hexadécimal. Ce nombre identifie le commit parce qu'il est généré à partir de tout son contenu -- changer le moindre caractère de l'un des fichiers change le nombre\footnote{Pour ceux qui veulent aller encore plus loin, c'est un hash en SHA-1, créé par la NSA. SHA-1 n'est plus considéré comme cryptographiquement protégé, mais ce n'est pas grave dans le cas de Git.}, on l'appelle le ``hash'' du commit.

Chaque commit connaît le hash de son parent (le commit précédent). Cela veut dire que vous pouvez remonter tout l'historique du projet à partir de n'importe quel commit, jusqu'à la création du projet (le premier commit est le seul qui a le droit de ne pas avoir de parent\footnote{En fait, ce n'est absolument pas vrai et Git est complètement capable de gérer plusieurs ``racines''. Par contre, c'est considéré comme une pratique très avancée et cela rend beaucoup de fusions très compliquées : la preuve, le noyau de Linux (pour lequel Git a été créé) contient 768~459 commits, dont seulement 4~racines.}). Cela permet de pouvoir régler les conflits plus facilement (Git est capable de remonter jusqu'au premier parent commun, puis redescendre en appliquant toutes les modifications des deux branches, on en reparlera page \pageref{end-branch}, ``\nameref{end-branch}''), mais cela permet aussi à Git de vérifier l'authenticité du projet. Puisque le hash change qu'elle que soit la modification de n'importe quel commit, Git se rend compte immédiatement des corruptions. Par exemple, si le serveur est corrompu et que vous essayez de ``git pull'', Git vous préviendras que la version du serveur est invalide\footnote{Si vous avez joué avec les Bitcoins ou les Ethereums, vous remarquerez peut-être que les commits et les blocs ont beaucoup en commun ; c'est normal, ils fonctionnent selon la même théorie : une référence vers le parent et l'utilisation de hashs. Bitcoin utilise l'algorithme SHA-256, qui est plus puissant et plus solide que SHA-1... mais c'est le même principe, cela s'appelle un Arbre de Merkle.}.

Revoici l'exemple précédent :

\begin{minted}{bash}
* ce23c9f Préparation pour le HTML
*   753fb53 Merge branch 'master'
|\  
| * ad6bfcb Message plus précis: pas besoin d'issue si on fait une MR
| *   5490b8e Typo 'acceuil' dans README
| |\  
| | * 2068086 Erreur pas jolie Bravo
| |/  
* | 9aa09e2 Added .idea/ to .gitignore
|/  
* 2a5d7a8 Mise à jour du README
* bd95463 Cours du 15 juin 2018
\end{minted}

Dans cet exemple :

\begin{description}
\item[ce23c9] Parent : {\tt 753fb53}
\item[2068086] Parent : {\tt 2a5d7a8}
\item[bd95463] Orphelin, c'est le premier commit !
\item[753fb53] Deux parents : {\tt 9aa09e2} et {\tt ad6bfcb}, c'est un commit ``de fusion'' ; idem pour 5490b8e
\end{description}

On trouve donc trois types de commits:

\begin{itemize}
\item Commit ``normal'', un parent
\item Commit racine, pas de parent
\item Commit de fusion (``merge commit''), 2 parents\footnote{Techniquement, un commit de fusion peut avoir plus de deux parents, mais c'est très rare et ce n'est fait que par des experts, cela s'appelle un ``commit-pieuvre'' (octopus commit) Dans le noyau Linux, c'est assez courant en raison de l'expérience des lieutenants et de Torvalds, sur les environ 700~000 commits, il y a 1~549 commits-pieuvre, dont le plus gros a 66 parents ! Pour un exemple de projet plus ``normal'', le repo de Rails comporte 63~000~commits dont 0~commit-pieuvre.}
\end{itemize}

Maintenant, qu'est-ce qu'une branche?

\subsection{Les branches}

\subsubsection{Introduction}

Vous voyez bien que la racine de l'arbre est un commit solitaire, mais les commits les plus à l'extrémité (les ``feuilles'') peuvent être très nombreuses:

\begin{minted}{bash}
      1 2 master
A-B-C-----F
   \--D
     \--E
\end{minted}

Sur ce schéma, on voit bien l'historique, ce projet a une racine (A) et trois feuilles (F, D et E).

En fait, les branches sont juste une manière de se souvenir de l'existence des feuilles. Par exemple, dans le schéma précédent, la branche ``master'' représente le commit F, la branche ``1'' représente le commit D, et la branche ``2'' représente le commit E.

\subsubsection{Ajouter un nouveau commit à une branche}

L'idée est très simple: si vous êtes actuellement sur la branche ``1'' et que vous faites un nouveau commit, l'historique deviendra:

\begin{minted}{bash}
        2 master 1
A-B-C-----F
   \--D----------G
     \--E
\end{minted}

On remarque que le nouveau commit (G) est bien dans la branche ``1''. Le parent de G est D (qui été précédemment le commit sur lequel pointait 1). 1 s'est déplacée et pointe maintenant sur le nouveau commit le plus récent, G. On remarque que, à part la branche 1 qui s'est déplacée, absolument aucune modification n'a été effectuée aux commits précédents: le contenu des autres branches est identique, le contenu de l'ancienne branche 1 est identique.

\subsubsection{Duplication des branches}

En fait, même si vous ne vous en êtes pas rendu compte, vous utilisez des branches depuis que vous avez commencé Git. En réalité, chaque machine qui a une copie du repo (chaque clone + l'original) contient aussi une copie de toutes les branches.

Si l'on reprend l'exemple précédent:

\begin{minted}{bash}
origin       1 2 master
local        1 2 master
       A-B-C-----F
          \--D
            \--E
\end{minted}

On retrouve les mêmes branches qu'avant, sur la ligne ``local''. Ce sont les versions des branches sur votre machine.

Les nouvelles branches qui viennent d'apparaître sont les versions des branches sur le serveur ``origin''\footnote{De même que la branche par défaut s'appelle ``master'', le serveur par défaut (l'adresse que vous avez utilisé lors du clone) est appelé ``origin''. Vous pouvez la renommer etc comme vous le souhaitez, cela n'a pas d'impact.}. On les appelle `serveur/branche', donc ici, `origin/master', `origin/1` et `origin/2' pour être sûr de ne pas les confondre avec les branches locales. Les branches locales n'ont pas de préfixe, elles s'appellent toujours `master', `1' et `2'.

Reprenons le scénario précédent, avec à nouveau un commit dans le branche 1 :

\begin{minted}{bash}
origin       1 2 master
local          2 master 1
       A-B-C-----F
          \--D----------G
            \--E
\end{minted}

Jusque-là, vous ne devez pas être surpris : on a modifié la branche locale mais on n'a pas communiqué la modification au serveur (on n'a pas utilisé `push' ou similaire). Le serveur ne sait pas que l'on créé un nouveau commit, donc ses branches ne changent pas.

Maintenant, poussons la branche 1 (avec {\tt git push}). Le serveur reçoit que la branche 1 pointe sur G, alors que origin/1 pointe sur D. Il essaie de trouver un ancêtre commun à G et D.

Ici, il découvre que D est un ancêtre direct de G, donc il est dans un cas simple: 1 est en avance sur origin/1, donc il déplace origin/1 sur G.

Maintenant, on a :

\begin{minted}{bash}
origin         2 master 1
local          2 master 1
       A-B-C-----F
          \--D----------G
            \--E
\end{minted}

Et c'est bon, le serveur est synchronisé !

Normalement, ce que je viens de vous expliquer devrait beaucoup vous faire penser à la page \pageref{régler-conflits}, ``\nameref{régler-conflits}''. C'est normal... c'est la même chose ! Jusqu'ici, vous aviez des conflits entre master et origin/master, maintenant vous pouvez avoir des conflits entre d'autres branches (mais croyez-moi, cela va permettre d'en avoir moins souvent).

Pourquoi est-ce que cela permet d'avoir moins de conflits ? C'est très simple. Les conflits ``ennuyants'', c'est-à-dire ceux qui arrivent quand deux personnes modifient la même partie d'un fichier, ne peuvent arriver que si deux personnes modifient la même partie d'un fichier !

En fait, la stratégie est très simple : chaque personne a sa propre branche attitrée. Voici les avantages:

\begin{itemize}
\item Chaque personne travaille dans sa propre version du projet, donc il n'y a jamais de cas où deux personnes modifient le même code.
\item Si votre commit ne compile pas, ce n'est pas grave, vous pouvez quand même l'envoyer au serveur. Vous êtes dans votre propre branche donc cela n'embêtera pas vos coéquipiers, et comme ça vous pouvez récupérer votre travail chez vous pour le continuer plus tard.
\end{itemize}

\section{HEAD\label{head}}

\subsection{Introduction}

{\tt HEAD} n'est pas à proprement parlé une branche, mais il fonctionne de manière similaire.

Git maintient deux ``zones'', l'arbre et l'espace de travail. L'``arbre'' désigne la représentation interne du projet (stockée dans le .git, contient l'historique etc.), et l'``espace de travail'' désigne tout simplement l'endroit où vous travaillez: vos fichiers.

\subsection{Savoir où se trouve HEAD} Quand vous affichez l'historique\footnote{Grâce à l'alias {\tt glog}, cf. \textit{\nameref{alias}}, page \pageref{alias}.}, Git vous montre la position de HEAD:

\begin{minted}{bash}
> git glog
* 703b003 (HEAD -> master) Added .out files to gitignore...
* 97732d2 Added command "make help"
\end{minted}

Comme vous le voyez, Git affiche que HEAD pointe sur {\tt master} (ligne 2).

Cela veut dire que le contenu des fichiers que vous voyez dans le projet correspondent à la branche {\tt master}, qui elle-même correspond au commit {\tt 703b003} ; c'est donc ce commit que vous voyez dans vos fichiers.

\subsection{Déplacer HEAD\label{move-head}}

Comme promis depuis le début de ce document, nous allons enfin pouvoir explorer l'historique, retourner dans le passé, etc.

Puisque HEAD représente les fichiers visibles, il suffit de déplacer HEAD. Cela se fait avec la commande \mintinline{bash}{git checkout}.

À noter que l'on ne peut pas déplacer HEAD tout le temps. Par exemple, Git refuse de déplacer HEAD si un des fichiers présent dans l'état Staged est différent de l'arrivée, parce que ce fichier serait perdu.
Dans ce cas, vous devez soit abandonner les modifications\footnote{Cf. \nameref{staged-unstaged}, page \pageref{staged-unstaged}.},
faire un commit\footnote{Cf. \nameref{commit}, page \pageref{commit}.},
ou utiliser {\tt git stash}\footnote{Cf. \nameref{stash}, page \pageref{stash}.}.

\subsubsection{Retourner voir un ancien commit \& headless mode}

Pour retourner à un ancien commit, il suffit d'exécuter:

\begin{minted}{bash}
git checkout COMMIT_HASH
# Par exemple:
git checkout 703b003
\end{minted}

Vous êtes maintenant en mode ``tête détachée'' (headless). Cela signifie que votre HEAD pointe sur un commit et non sur une branche.

Pour revenir au présent en mode normal, il suffit de retourner sur une branche:

\begin{minted}{bash}
git checkout NOM
# Exemple: retour à la branche master
git checkout master
\end{minted}

En mode headless, il est dangereux de créer des nouveaux commits! En effet, ils seront dans l'arbre mais dans aucune branche. Si vous changez de branche, vous ne pourrez plus jamais retourner au commit (sauf si vous connaissez son hash).

Pour éviter ce problème, vous pouvez créer une nouvelle branche \textit{à partir de l'ancien commit}, puis vous déplacer sur cette branche. Comme cela, tous nouveaux commits seront placés sur cette branche.

\begin{minted}{bash}
git checkout -b NOM COMMIT_HASH
# Exemple:
git checkout -b ancien 703b003
\end{minted}

\subsubsection{Changer de branche}

Pour passer d'une branche à l'autre, vous pouvez simplement utiliser:

\begin{minted}{bash}
git checkout NOM
# Exemple: aller sur la branche master
git checkout master
\end{minted}

\section{Commandes sur les branches}

Jusque-là, nous avons vu la théorie à propos des branches. Il est temps de parler réellement de leur utilisation.

Quand nous avons parlé des branches, plus tôt, nous avons surtout parlé du cas où les branches sont publiées sur le serveur... mais rien ne vous y oblige! Vous pouvez avoir des branches locales qui ne serve qu'à vous.

\subsection{Créer une branche}

La nouvelle branche sera créée à partir du commit actuel:

\begin{minted}{bash}
git branch NOM
# Exemple:
git branch test-implementation-scores
\end{minted}

Pour créer une branche à partir d'un autre commit que celui actuel:

\begin{minted}{bash}
git checkout -b NOM COMMIT_HASH
# Exemple:
git checkout -b old 703b003
\end{minted}

À noter que cela crée la branche, mais ne vous déplace pas dedans. Pour passer d'une branche à l'autre, il suffit d'utiliser \mintinline{bash}{git checkout NOM}.

\subsection{Publication de la branche}

Dans la partie précédente, vous venez de créer une branche locale. Pour la publier sur le serveur (ou n'importe quel hôte distant) vous pouvez effectuer (dans la branche que vous voulez publier):

\begin{minted}{bash}
git push --set-upstream origin NOM
\end{minted}

en remplaçant NOM par le nom que vous voulez donner à la branche côté serveur (le nom côté serveur et local peut être différent).

Si vous utilisez d'autres hôtes qu'{\tt origin}, vous pouvez simplement remplacer le nom de l'hôte.

Cela permet à vos partenaires d'accéder à la branche aussi.

\subsection{Supprimer ou fusionner une branche\label{end-branch}}

La raison pour laquelle on crée une branche est souvent de tester des nouvelles fonctionnalités, avec comme but de fusionner la branche à votre branche principale quand tout fonctionne.

Vous pouvez donc soit supprimer la branche (si vous n'en voulez plus), soit la fusionner (si le résultat vous plaît).

\subsubsection{Supprimer une branche locale}

Attention, cette commande supprime la branche de votre côté mais ne la supprime pas côté serveur (si elle était publiée)!

\begin{minted}{bash}
git branch -d NOM
# Exemple:
git branch -d scores
\end{minted}

Cette commande est ``safe'': elle ne supprimera la branche que si la branche a déjà été fusionnée (donc aucun travail ne sera perdu lors de la suppression). Pour supprimer la branche même si elle n'est pas fusionnée, il suffit d'utiliser {\tt -D} au lieu de {\tt -d}\footnote{Pour ceux qui aiment les détails, {\tt -d} est un alias pour \mintinline{bash}{--delete} et {\tt -D} est un alias pour \mintinline{bash}{--delete --force}.}

\begin{minted}{bash}
git branch -D NOM
\end{minted}

\paragraph{À savoir} Pour effectuer ces commandes, il faut être dans une autre branche!

\subsubsection{Supprimer une branche distante}

Pour supprimer une branche distante, vous pouvez utiliser:

\begin{minted}{bash}
git push --delete origin NOM
\end{minted}

en remplaçant NOM par le nom de la branche, et en changeant {\tt origin} si vous utilisez plusieurs serveurs.

À noter que cela ne supprime que la branche distante, et non la version locale. Pour supprimer les deux, utilisez:

\begin{minted}{bash}
git push --delete origin NOM
git branch -d NOM
\end{minted}

\subsubsection{Merge}

Pour fusionner la branche à une autre, vous pouvez utiliser:

\begin{minted}{bash}
git merge BRANCHE
\end{minted}

Cela fusionnera la branche BRANCHE à la branche actuelle. Vous pouvez maintenant supprimer BRANCHE.

\subsubsection{Rebase}

Au contraire de Merge, Rebase est une opération destructrice qui modifie l'arbre. Vous pouvez l'utiliser sans problèmes si la branche à fusionner n'est que locale, mais si vous l'avez publié, cela va poser de nombreux problèmes aux autres utilisateurs de votre projet.

Nous vous conseillons de ne jamais utiliser Rebase, sauf si vous êtes sûr de ce que vous faites.

Rebase a pour effet de supprimer la branche et tous ses commits, de les combiner en un, et d'ajouter ce ``commit de fusion'' à la branche actuelle.

\begin{minted}{bash}
git checkout RÉSULTAT
git rebase BRANCHE
\end{minted}

Cela va rembobiner tous les commits présents dans BRANCHE depuis son ancêtre commun avec RÉSULTAT, puis les réappliquer dans l'ordre à RÉSULTAT.

Tout le contenu de BRANCHE est donc présent dans RÉSULTAT, sans fusion, avec un historique linéaire plus propre.

Attention une fois encore, ne faites JAMAIS un Rebase sur du travail qui est disponible sur un serveur / pour un coéquipier!

\paragraph{Conflit pendant un Rebase}
Si un conflit survient pendant un Rebase, vous pouvez utiliser:

\begin{minted}{bash}
git rebase --skip # Ignorer le conflit
git rebase --continue # Après avoir réglé le conflit, pour continuer
git rebase --abort # Abandonner le rebase
\end{minted}

\part{GitLab et GitHub}

GitLab et GitHub sont des sites qui permettent de hoster un dépôt Git. Ils donnent de nombreuses fonctions en plus.

\section{Les forks : projets à grande échelle}

Habituellement, Git utilise un projet unique dans lequel tout le monde travaille, dans des branches différentes. Avec l'arrivée des sites comme GitLab et GitHub, ce n'est pas pratique, parce que cela empêche d'utiliser les permissions.

Quand vous créez votre projet, vous ne voulez pas que n'importe qui vienne le modifier. Vous allez donc le rendre public, mais interdire que quiconque puisse y pousser (comportement par défaut).

Cependant, vous pouvez vouloir autoriser au public de proposer des modifications (que vous vérifierez avant de les intégrer). C'est pour cela que les forks existent.

Un fork, c'est une copie complète du projet. Au contraire d'une branche, qui ne copie que le contenu du projet, un fork est une vraie copie (comme si vous faisiez un copié-collé à la main, avec un nouveau {\tt .git} etc.).

\subsection{Dans les projets Open Source}

Dans les projets publics, les forks sont utilisés pour proposer des modifications.

Par exemple, voici la démarche à suivre pour proposer une modification à ce cours.

\begin{enumerate}
\item Allez sur le GitLab du projet.
\item Connectez-vous à votre compte.
\item Cliquez en haut de la page sur le bouton ``fork''. Le site vous guide à travers les étapes.
\item Clonez votre projet
\item Optionnel mais conseillé: créez une nouvelle branche et publiez-la
\item Faites les modifications que vous voulez intégrer
\item {\tt git push}
\item Quand vous êtes satisfait de vos modifications, retournez sur le GitLab du projet (l'original, pas le fork), dans le menu de gauche, allez dans ``merge~request''
\item Créez une nouvelle Merge Request (pour GitHub: Pull Request), avec comme source votre branche dans votre fork et comme destination la branche d'origine
\item Validez tout.
\end{enumerate}

Les propriétaires du projet pourront ensuite analyser vos modifications. Si elles leur plaisent, ils peuvent les intégrer au projet.

Dans tous les cas, lisez vos mails! Une Merge Request n'est presque jamais acceptée directement, il y aura probablement des petites modifications à faire.

\subsection{Dans les entreprises}

Pour les projets ayant beaucoup de collaborateurs (par exemple le noyau Linux), il peut être nécessaire de créer plusieurs équipes. Dans ce cas-là, chaque équipe travaille sur un fork différent, et le coordinateur va fusionner les forks ensemble petit-à-petit. Comme cela, chaque équipe peut travailler indépendamment des autres.

\section{Merge et Pull Request}

\section{Le workflow}

\subsection{GitHub}

\subsection{GitLab}

\part{Git avancé}

\section{Les étiquettes / tags\label{tags}}

\section{Stash\label{stash}}

\section{Les submodules\label{submodules}}

\end{document}
